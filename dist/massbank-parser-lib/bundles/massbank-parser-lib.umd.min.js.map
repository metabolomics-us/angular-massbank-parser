{"version":3,"sources":["../../../projects/massbank-parser-lib/src/lib/massbank-parser-lib.service.ts","../../../projects/massbank-parser-lib/src/lib/massbank-parser-lib.module.ts"],"names":["logger","_this","this","convertWithCallback","data","callback","trim","str","replace","addMetaData","value","category","spectrum","match","exec","key","toLowerCase","reg_1","test","meta","push","name","reg_2","getIt","names","inchi","comments","accurate","regexAttr","regexAnnotation","buf","toString","indexOf","idx","substring","reg","i","length","object","regexSpectra","regExAccurateMass","ions","isAbsolute","parseFloat","join","warn","JSON","stringify","convertFromData","countSpectra","count","pos","MassbankParserLibService","i0","ɵɵinject","NGXLogger","factory","ɵfac","providedIn","MassbankParserLibModule","providers","imports","LoggerModule","forRoot","level","NgxLoggerLevel","DEBUG","serverLogLevel","OFF","i1"],"mappings":"yXAQE,SAAuCA,GAAvC,IAAAC,EAAAC,KAAuCA,KAAAF,OAAAA,EASvCE,KAAAC,oBAAuB,SAACC,EAAMC,GAE5B,IAAIC,EAAO,SAACC,GACV,OAAOA,EAAIC,QAAQ,SAAU,IAAIA,QAAQ,SAAU,KAIrD,SAASC,EAAYC,EAAOC,EAAUC,GACpB,MAAZD,IACFA,EAAWL,EAAKK,IAGlB,IAEIE,EAFM,qBAEMC,KAAKJ,GAErB,GAAa,MAATG,EAAJ,CAKA,IAAIE,EAAMT,EAAKO,EAAM,GAAGG,eAQxB,GALgB,eAAZL,IACFA,EAAW,qBAIF,kBAAPI,EAAyB,CAC3B,IAAIE,EAAM,2BAENA,EAAIC,KAAKL,EAAM,IACjBD,EAASO,KAAKC,KAAK,CAACC,KAAI,EAASX,MAAOJ,EAAKW,EAAIH,KAAKD,EAAM,IAAI,IAAKF,SAAQ,IAG7EC,EAASO,KAAKC,KAAK,CAACC,KAAI,EAASX,MAAOJ,EAAKO,EAAM,IAAKF,SAAQ,IAKpE,GAAW,iBAAPI,EAKF,IAJA,IAAIO,EAAM,qBAENC,EAAQD,EAAIR,KAAKD,EAAM,IAEX,MAATU,GACLX,EAASO,KAAKC,KAAK,CAACC,KAAI,gBAAqBX,MAAOJ,EAAKiB,EAAM,IAAKZ,SAAQ,IAE5EY,EAAQD,EAAIR,KAAKD,EAAM,SAMzBD,EAASO,KAAKC,KAAK,CAACC,KAAI,EAASX,MAAOJ,EAAKO,EAAM,IAAKF,SAAQ,KAsBpE,IAlBA,IAaIE,EAbAD,EAAW,CAACY,MAAO,GAAIL,KAAM,GAAIM,MAAO,GAAIC,SAAU,GAAIC,UAAU,EAAMf,SAAU,IAGpFgB,EAAY,qBAIZC,EAAkB,8DAQlBC,EAAM1B,EAAK2B,SAAS,QAGgB,OAAhClB,EAAQe,EAAUd,KAAKgB,KAC7B,GAAiB,YAAbjB,EAAM,IAAiC,gBAAbA,EAAM,IAAqC,cAAbA,EAAM,IAAmC,eAAbA,EAAM,IAAoC,iBAAbA,EAAM,IAAsC,SAAbA,EAAM,SAGrJ,GAAiB,YAAbA,EAAM,GACbD,EAASY,MAAMJ,KAAKd,EAAKO,EAAM,UAE5B,GAAiB,kBAAbA,EAAM,GAEb,KAA+C,OAAvCA,EAAQgB,EAAgBf,KAAKV,KACnCQ,EAASO,KAAKC,KAAK,CAACT,SAAU,aAAcU,KAAMf,EAAKO,EAAM,IAAKH,MAAOJ,EAAKO,EAAM,WAGnF,GAAgB,YAAZA,EAAM,IAAgC,YAAZA,EAAM,GAGvC,GAFAA,EAAM,GAAKP,EAAKO,EAAM,IAElBA,EAAM,GAAGmB,QAAQ,WAAa,EAAG,CAEnC,IAAIC,EAAMpB,EAAM,GAAGmB,QAAQ,UAC3BC,EAAMpB,EAAM,GAAGmB,QAAQ,SAAUC,EAAM,GAGrCrB,EAASa,MADPQ,GAAO,EACQ3B,EAAKO,EAAM,GAAGqB,UAAUD,IAExBpB,EAAM,QAGzBD,EAASY,MAAMJ,KAAKP,EAAM,QAGT,WAAZA,EAAM,GACbD,EAASc,SAAWpB,EAAKO,EAAM,IAG3BA,EAAM,GAAGmB,QAAQ,SAAW,GAER,yBAAbnB,EAAM,IAEO,sBAAbA,EAAM,IAEM,kBAAZA,EAAM,IAGI,qBAAZA,EAAM,GARbJ,EAAYI,EAAM,GAAIA,EAAM,GAAID,GAahCA,EAASO,KAAKC,KAAK,CAACC,KAAMf,EAAKO,EAAM,IAAKH,MAAOJ,EAAKO,EAAM,MAOlE,IAFA,IAAIsB,EAAM,2BAEDC,EAAI,EAAGA,EAAIxB,EAASO,KAAKkB,OAAQD,IAAK,CAC7C,IAAIE,EAAS1B,EAASO,KAAKiB,GAEvBD,EAAIjB,KAAKoB,EAAOjB,QAClBiB,EAAOjB,KAAOc,EAAIrB,KAAKwB,EAAOjB,MAAM,IAIf,MAAnBiB,EAAO3B,UAAoBwB,EAAIjB,KAAKoB,EAAO3B,YAC7C2B,EAAO3B,SAAWwB,EAAIrB,KAAKwB,EAAO3B,UAAU,IAoBhD,IAZA,IAAI4B,EAAe,2GAMfC,EAAoB,uBAEpBC,EAAO,GAEPC,GAAa,EAE0B,OAAnC7B,EAAQ0B,EAAazB,KAAKgB,KAE5BjB,EAAM,GAAGG,cAAcgB,QAAQ,MAAQ,IACzCnB,EAAM,GAAK8B,WAAW9B,EAAM,IAAIkB,YAE9BlB,EAAM,GAAGG,cAAcgB,QAAQ,MAAQ,IACzCnB,EAAM,GAAK8B,WAAW9B,EAAM,IAAIkB,YAE9BlB,EAAM,GAAGG,cAAcgB,QAAQ,MAAQ,IACzCnB,EAAM,GAAK8B,WAAW9B,EAAM,IAAIkB,YAG9BlB,EAAM,GAAK,IACb6B,GAAa,GAGfD,EAAKrB,KAAK,CAACP,EAAM,GAAIA,EAAM,GAAIA,EAAM,KAGhC2B,EAAkBtB,KAAKL,EAAM,MAChCD,EAASe,UAAW,GAKxB,IAASS,EAAI,EAAGA,EAAIK,EAAKJ,OAAQD,IAE7BK,EAAKL,GADHM,EACQD,EAAKL,GAAG,GAAK,IAAMK,EAAKL,GAAG,GAE3BK,EAAKL,GAAG,GAAK,IAAMK,EAAKL,GAAG,GAKzCxB,EAASA,SAAW6B,EAAKG,KAAK,KAI1BH,EAAKJ,QAAUzB,EAASY,MAAMa,OAChChC,EAASO,GAGTX,EAAKD,OAAO6C,KAAK,oDAAsDzC,EAAO,6BAA+B0C,KAAKC,UAAUnC,KAShIV,KAAA8C,gBAAmB,SAAC5C,EAAMC,GACxB,OAAOJ,EAAKE,oBAAoBC,EAAMC,IAQxCH,KAAA+C,aAAgB,SAAC7C,GAIf,IAHA,IAAI8C,EAAQ,EACRC,GAAO,GAE6C,IAAhDA,EAAM/C,EAAK4B,QAAQ,cAAemB,EAAM,KAC9CD,IAIF,OAAQA,GAAS,EAAIA,EAAQ,qCAjPpBE,GAAwBC,EAAAC,SAEfC,EAAAA,iDAFTH,EAAwBI,QAAxBJ,EAAwBK,KAAAC,WAFvB,eCUd,6CAAaC,iEAAAA,IAAuBC,UAFvB,CAACR,GAAyBS,QAAA,CAN5B,CACPC,EAAAA,aAAaC,QAAQ,CACnBC,MAAOC,EAAAA,eAAeC,MACtBC,eAAgBF,EAAAA,eAAeG,2EAKxBT,EAAuB,CAAAE,QAAA,CAAAQ,EAAAP","sourcesContent":["import {Inject, Injectable} from '@angular/core';\nimport { NGXLogger} from \"ngx-logger\";\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MassbankParserLibService {\n\n  constructor(@Inject(NGXLogger) private logger: NGXLogger) { }\n\n  /**\n   * Converts the data using a callback\n   * Follows the MassBank Record Format v2.09\n   * http://www.massbank.jp/manuals/MassBankRecord_en.pdf\n   * @param data\n   * @param callback\n   */\n  convertWithCallback =  (data, callback) => {\n    // Trim white spaces\n    let trim = (str) => {\n      return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    };\n\n\n    function addMetaData(value, category, spectrum){\n      if (category != null) {\n        category = trim(category);\n      }\n\n      let sub = /(\\w+[\\/]*\\w)\\s(.+)/;\n\n      let match = sub.exec(value);\n\n      if (match == null) {\n        return;\n      }\n\n      // Add metadata as an array\n      let key = trim(match[1].toLowerCase());\n\n      //switch categories\n      if (category == 'FOCUSED_ION') {\n        category = 'MASS_SPECTROMETRY'\n      }\n\n      //let's cutoff the units\n      if (key == 'retention_time') {\n        let reg = /([0-9]+\\.?[0-9]+).*min.*/;\n\n        if (reg.test(match[2])) {\n          spectrum.meta.push({name: (key), value: trim(reg.exec(match[2])[1]), category: (category)});\n        }\n        else {\n          spectrum.meta.push({name: (key), value: trim(match[2]), category: (category)});\n        }\n      }\n\n      //make sure this is a double or ignore it\n      if (key == 'precursor_m/z') {\n        let reg = /([0-9]+\\.?[0-9]+)/g;\n\n        let getIt = reg.exec(match[2]);\n\n        while (getIt != null) {\n          spectrum.meta.push({name: ('precursor m/z'), value: trim(getIt[1]), category: (category)});\n\n          getIt = reg.exec(match[2])\n        }\n      }\n\n      //just deal with it\n      else {\n        spectrum.meta.push({name: (key), value: trim(match[2]), category: (category)});\n      }\n    }\n    // Initial spectrum\n    let spectrum = {names: [], meta: [], inchi: '', comments: '', accurate: true, spectrum: ''};\n\n    // Regular expression for getting the attributes\n    let regexAttr = /\\s*(\\S+):\\s(.+)\\s/g;\n\n    // Regular expression for getting the annotations\n    // Get entire annotation: /(\\s\\s(?:\\d+\\.?\\d*)(?:\\s\\d+)?\\s+[^\\s\\d]+.+)/g\n    let regexAnnotation = /\\s\\s(\\d+\\.?\\d*)(?:\\s\\d+)?\\s+.*(\\[.+\\][\\+\\-]?(?:\\(.+\\))?).*/g;\n\n    // Regular expression for getting subtags and values\n    let regexSubtags = /(\\w+)\\s(.+)/;\n\n    // Regex matches\n    let match;\n\n    let buf = data.toString('utf8');\n\n    // Builds our metadata object\n    while ((match = regexAttr.exec(buf)) != null) {\n      if (match[1] === 'PK$PEAK' || match[1] === 'PK$NUM_PEAK' || match[1] === 'CH$SMILES' || match[1] === 'CH$FORMULA' || match[1] === 'RECORD_TITLE' || match[1] === 'DATE') {\n        //skip\n      }\n      else if (match[1] === 'CH$NAME') {\n        spectrum.names.push(trim(match[2]));\n      }\n      else if (match[1] === 'PK$ANNOTATION') {\n        // Parse annotation entries\n        while ((match = regexAnnotation.exec(data)) != null) {\n          spectrum.meta.push({category: \"annotation\", name: trim(match[2]), value: trim(match[1])});\n        }\n      }\n      else if (match[1] == 'CH$IUPAC' || match[1] == 'CH$INCHI') {\n        match[2] = trim(match[2]);\n\n        if (match[2].indexOf('InChI=') > -1) {\n          // Look for second instance of 'InChI='\n          let idx = match[2].indexOf('InChI=');\n          idx = match[2].indexOf('InChI=', idx + 1);\n\n          if (idx > -1) {\n            spectrum.inchi = trim(match[2].substring(idx));\n          } else {\n            spectrum.inchi = match[2];\n          }\n        } else {\n          spectrum.names.push(match[2])\n        }\n      }\n      else if (match[1] == 'COMMENT') {\n        spectrum.comments = trim(match[2]);\n      }\n      else {\n        if (match[1].indexOf('LINK') > -1) {\n          addMetaData(match[2], match[1], spectrum);\n        } else if (match[1] === 'AC$MASS_SPECTROMETRY') {\n          addMetaData(match[2], match[1], spectrum);\n        } else if (match[1] === 'AC$CHROMATOGRAPHY') {\n          addMetaData(match[2], match[1], spectrum);\n        } else if (match[1] == 'MS$FOCUSED_ION') {\n          addMetaData(match[2], match[1], spectrum);\n        }\n        else if (match[1] == 'MS$DATA_PROESSING') {\n          addMetaData(match[2], match[1], spectrum);\n        }\n\n        else {\n          spectrum.meta.push({name: trim(match[1]), value: trim(match[2])});\n        }\n      }\n    }\n\n    let reg = /^(?:[a-zA-Z\\s])*\\$(.*)$/i;\n\n    for (let i = 0; i < spectrum.meta.length; i++) {\n      let object = spectrum.meta[i];\n\n      if (reg.test(object.name)) {\n        object.name = reg.exec(object.name)[1];\n      }\n\n\n      if (object.category != null && reg.test(object.category)) {\n        object.category = reg.exec(object.category)[1];\n      }\n    }\n\n    // Builds the spectrum\n    // Floating point/scientific notation regex:\n    //     (?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?\n    // from: http://stackoverflow.com/a/658662/406772\n    let regexSpectra = /\\s\\s((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)\\s((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)\\s(\\d+)\\b/g;\n\n    /**\n     * is this an accurate mass\n     * @type {RegExp}\n     */\n    let regExAccurateMass = /([0-9]*\\.?[0-9]{3,})/;\n\n    let ions = [];\n\n    let isAbsolute = false;\n\n    while ((match = regexSpectra.exec(buf)) != null) {\n      // Convert scientific notation\n      if (match[1].toLowerCase().indexOf('e') > -1) {\n        match[1] = parseFloat(match[1]).toString();\n      }\n      if (match[2].toLowerCase().indexOf('e') > -1) {\n        match[2] = parseFloat(match[2]).toString();\n      }\n      if (match[3].toLowerCase().indexOf('e') > -1) {\n        match[3] = parseFloat(match[3]).toString();\n      }\n\n      if (match[2] > 0) {\n        isAbsolute = true;\n      }\n\n      ions.push([match[1], match[2], match[3]]);\n\n      // Used to determine if this is an accurate mass spectra or not\n      if (!regExAccurateMass.test(match[1])) {\n        spectrum.accurate = false;\n      }\n    }\n\n    // Replace intensities with absolute or relative intensities\n    for (let i = 0; i < ions.length; i++) {\n      if (isAbsolute) {\n        ions[i] = ions[i][0] + ':' + ions[i][1];\n      } else {\n        ions[i] = ions[i][0] + ':' + ions[i][2];\n      }\n    }\n\n    // Join ions to create spectrum string\n    spectrum.spectrum = ions.join(' ');\n\n\n    // Make sure we have at least a spectrum and name before returning the spectrum\n    if (ions.length && spectrum.names.length) {\n      callback(spectrum);\n    }\n    else {\n      this.logger.warn(\"was no able to find valid spectra for record:\\n\\n\" + data + \"\\n\\n build object was:\\n\\n\" + JSON.stringify(spectrum));\n    }\n  };\n\n  /**\n   * converts the data using a callback\n   * @param data\n   * @param callback\n   */\n  convertFromData =  (data, callback) => {\n    return this.convertWithCallback(data, callback);\n  };\n\n  /**\n   * counts the number of mass spectra in this library file\n   * @param data\n   * @returns {number}\n   */\n  countSpectra =  (data) => {\n    let count = 0;\n    let pos = -1;\n\n    while ((pos = data.indexOf('PK$NUM_PEAK', pos + 1)) != -1) {\n      count++;\n    }\n\n    // Massbank record files are only valid if they have a single spectrum\n    return (count <= 1 ? count : 0);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { MassbankParserLibService } from './massbank-parser-lib.service';\nimport {LoggerModule, NgxLoggerLevel} from \"ngx-logger\";\n\n\n@NgModule({\n  imports: [\n    LoggerModule.forRoot({\n      level: NgxLoggerLevel.DEBUG,\n      serverLogLevel: NgxLoggerLevel.OFF\n    })\n  ],\n  providers: [MassbankParserLibService]\n})\nexport class MassbankParserLibModule { }\n"]}